基础

进制转换
2进制转8/16进制 
    可将2进制数的3/4位为一组进行换算 (2进制小数点后同理计算 位数由高到低)
10进制转2/8/16 
    可将10进制数除以2/8/16 位数从低到高 余数为当前位值 商为除数重复上述动作 直至商为0
10进制浮点数转2进制
    整数部分同上
    小数部分做乘2处理 位数由高到低 结果整数部分为当前位 小数部分重复上述动作 直至结果为0 (可能无限循环)
    转换结果按照IEEE754标准保存 
    float  符号位(0为正1为负)+尾数(8位)+阶码(23位)
    double 符号位(0为正1为负)+尾数(11位)+阶码(52位)
    10101.0110101110001001001001..... = 1.01010110101110001001001001..... * 2^4(指数偏移值)
    float  0 + 10000010(127 + 4) + 01010110101110001001001(截取23位 精度丢失的原因)
    double 0 + 10000000011(1023 + 4) + 01010110101110001001001....(截取52位)
10进制浮点数转2进制以外进制 可先转成2进制再转成其他进制

2进制运算
与   相同为1 不同为0
或   有1为1 其他为0
异或 不同为1 相同为0
同或 相同为1 不同为0
左移(<< n) 向左移动n位 右侧补0
右移(>> n) 向右移动n位 左侧补0

操作系统

字节序
小端字节序
    数值高位在内存低位(计算机容易取数)
大端字节序
    数值高位在内存高位(符合书写习惯 符号位在内存第一位 计算机取数先取数值高位 有额外运算)
例 0x12345678
小端字节序 0x78 0x56 0x34 0x12
大端字节序 0x12 0x34 0x56 0x78

中断
外部硬件&软件(代码)通过INTR(外设通过此线传递信号)/NMI(外设发生灾难性事故)&调用中断指令(int 8位立即数/int3 调试中断/into 溢出中断/bound 越界检查中断/ud2 未知指令中断) 强制cpu执行中断信号在中断向量表/中断描述符中对应的函数
非异常类中断(如网卡 键盘等外设要求cpu读数据 into中断指令)可被eflag寄存器中IF位屏蔽(0屏蔽1正常)

into 溢出中断
    指在运算过程中 产生的结果无法在分配的空间内存放(如int由8位存放 两个int数值相加后超出了8位) 则溢出标志位OF被置为1 此时程序调用into指令且中断屏蔽位IF=1 会调用中断向量号为4的溢出中断程序(函数)

保护模式
32位cpu 将16位运行模式称为实模式 32位运行模式称为保护模式
实模式 段基址存放物理地址 直接操作内存物理地址
保护模式 段基址存放选择子 通过下标对应全局描述符表中的段描述符表的虚拟地址 寻址后由操作系统+cpu转换成真实物理地址
保护模式下 除段寄存器以外的寄存器(通用寄存器 指令指针寄存器 标志寄存器)均为32位 其低位复用16位cpu的寄存器 向高位扩展一个16位的寄存器
保护模式下 新加入段描述符缓冲寄存器 用来缓存内存中的段描述符或实模式下段基址的偏移结果

全局描述符表(GDT) 所以程序公共使用
局部描述符表(LDT) 多任务模式下 每个任务私有的描述符表 任务切换时需重新初始化 极少用到
段描述符 存在于GDT&LDT中
    每个元素64位 用来描述一个段基址信息 其中低32位描述段基址的0-15位和段界限的0-15位(最大偏移量 偏移单位) 高32位描述段基址的16-31位 段界限的16-19位和段的基本信息
    段基本信息包括  
    段偏移单位(G位) 计算段界限的实际值 0: 偏移单位为1字节 1: 偏移单位为4kb字节
    段描述符(type位 S位) type4个字节 标识段是否被访问(A位) 是否为一致性代码段(C位) 是否可读(R位) 是否可执行(X位)
                       S位1个字节 标识段为系统段(0 各种门)或数据段(1 各种代码段 软件运行地址)
    段特权级(DPL 2位) 包括0-3四级 0级权限最高 运行操作系统代码 用户代码一般在3级
    段存在描述(P位) 标识段是否在内存中存在 0: 不存在 1: 存在
    段可用性描述(AVL) 描述段是否可用
    段类型(L位) 描述段位32位或64位  0: 32位 1: 64位 32位cpu默认0
    D/B位 描述段内偏移地址和操作数大小 D位在代码段起效 0: 16位有效地址&操作数 1: 32位有效地址&操作数
                                  B位在栈段起效 0: 使用16位栈寄存器sp 1: 使用32位栈寄存器esp

保护模式保护策略
段寄存器加载选择子时保护 检查描述符表下标是否合法 段类型和寄存器类型是否匹配 段是否存在(P位)
数据段和代码段加载保护 检查段偏移量是否超过段界限
栈段保护 入栈时是否超过栈段界限 (向上扩展可访问段界限最后一个字节 向下扩展可访问段界限最后一个字节-1 防止段碰撞)

特权级
cpu特权级分为0-3 数字越小特权级越高 0为内核特权级 1-2为系统程序特权级(面向虚拟机 硬件驱动程序) 3位用户程序特权级

TSS 任务状态段 处理器硬件支持多任务数据结构 每一任务(进程)都有单独的TSS
TSS保存特权级栈 每一个特权级有单独的栈 任务所需特权级由低到高 从TSS取出高一级特权级栈 特权级由高到低 从高特权级栈中取出低特权级栈地址





物理内存获取 (调用BOIS中断0X15 工作于实模式下)
子功能号 0xe820 获取全部物理内存 返回地址描述符结构
子功能号 0xe801 获取4GB以内的物理内存 0-15mb信息存放在AX/CX寄存器中 以1kb为单位 16mb-4gb信息存放在BX/DX寄存器中 以64kb为单位 (15mb-16mb地址为不可用内存 为历史ISA设备预留)
子功能号 0x88 获取1MB-64MB以内的物理内存 以1kb位单位

内存分页
引入分页前 段基址+段偏移量组成的线性地址直接映射成物理内存地址 内存碎片化严重时较难分配空间
引入分页后 段基址+段偏移量组成的线性地址映射成多个大小相等的虚拟内存页 每个内存页对应连续的一块物理内存 以达到连续线性地址映射非连续物理内存地址的效果 可以较为容易的分配空间

一级页表
页表起始地址存放在cr3寄存器中 每个进程都有独立的页表(从进程角度看 每个进程都独享4GB空间)
每页4KB 4GB被划分为 4GB/4KB=1048576页
线性地址通过 硬件 页部件转化为物理地址 其中线性地址高20位表示对应页在页表中的偏移位置 低12位表示在一页中的地址偏移位置
如 0X1234=00000000000000000001 001000110100 高20位*页表元素大小4字节 获取页表索引 最终物理地址=页表索引对应存放的地址+低12位

二级页表
每个一级页表需要占用4M的物理内存空间(32 * 1048576 = 4M) 且并不是所有页表项在一个进程中都会被使用 因此需要二级页表进一步打散一级页表所占用的物理内存
二级页表由页目录表 页表两级构成 在4G的内存空间中 页目录表共有1024个元素 每个元素4kb 指向一个包含1024个元素的页表 每个页表4kb
在寻址时 线性地址的高10位对应页目录表的下标 中间10位对应页表的下标 后12位对应页表的偏移量
如 0X1234567=00000001001000110100010101100111 高10位*每页目录元素大小4字节 获取页表物理地址 中间10位*页表元素大小4字节 获取页表中位置 低12位为页表元素的偏移量

页表元素组成
高20位指向物理地址的高20位 物理地址低12位默认补0 由线性地址低12位偏移量确定
低12位存放物理内存各种标志位 P位 存在位 0: 不存在于物理内存中 1: 存在于物理内存中
                        RW位 读写位 0: 可读不可写 1: 可读不可写
                        US位 普通用户/超级用户位 0: supervisor级 特权级3的程序不可访问 1: user级 任意特权级程序均可访问
                        PWT位 页级通写位 0: 不是高速缓存页 1: 普通内存/高速缓存页
                        PCD位 页级高速缓存禁止位 0: 禁止页使用高速缓存 1: 启用高速缓存
                        A位 访问位 0: 未被CPU访问 1: 已被CPU访问
                        D位 脏页位 0: 此页未被修改 1: 此页正在被修改
                        PAT位 页属性表位 默认0
                        G位 全局位 0: 非全局位 1: 全局位 (此页常驻TLB中)
                        AVL位 是否可用位 操作系统关注 CPU忽略




