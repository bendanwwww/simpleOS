基础

进制转换
2进制转8/16进制 
    可将2进制数的3/4位为一组进行换算 (2进制小数点后同理计算 位数由高到低)
10进制转2/8/16 
    可将10进制数除以2/8/16 位数从低到高 余数为当前位值 商为除数重复上述动作 直至商为0
10进制浮点数转2进制
    整数部分同上
    小数部分做乘2处理 位数由高到低 结果整数部分为当前位 小数部分重复上述动作 直至结果为0 (可能无限循环)
    转换结果按照IEEE754标准保存 
    float  符号位(0为正1为负)+尾数(8位)+阶码(23位)
    double 符号位(0为正1为负)+尾数(11位)+阶码(52位)
    10101.0110101110001001001001..... = 1.01010110101110001001001001..... * 2^4(指数偏移值)
    float  0 + 10000010(127 + 4) + 01010110101110001001001(截取23位 精度丢失的原因)
    double 0 + 10000000011(1023 + 4) + 01010110101110001001001....(截取52位)
10进制浮点数转2进制以外进制 可先转成2进制再转成其他进制

2进制运算
与   相同为1 不同为0
或   有1为1 其他为0
异或 不同为1 相同为0
同或 相同为1 不同为0
左移(<< n) 向左移动n位 右侧补0
右移(>> n) 向右移动n位 左侧补0

操作系统

字节序
小端字节序
    数值高位在内存低位(计算机容易取数)
大端字节序
    数值高位在内存高位(符合书写习惯 符号位在内存第一位 计算机取数先取数值高位 有额外运算)
例 0x12345678
小端字节序 0x78 0x56 0x34 0x12
大端字节序 0x12 0x34 0x56 0x78

中断
外部硬件&软件(代码)通过INTR(外设通过此线传递信号)/NMI(外设发生灾难性事故)&调用中断指令(int 8位立即数/int3 调试中断/into 溢出中断/bound 越界检查中断/ud2 未知指令中断) 强制cpu执行中断信号在中断向量表/中断描述符中对应的函数
非异常类中断(如网卡 键盘等外设要求cpu读数据 into中断指令)可被eflag寄存器中IF位屏蔽(0屏蔽1正常)

into 溢出中断
    指在运算过程中 产生的结果无法在分配的空间内存放(如int由8位存放 两个int数值相加后超出了8位) 则溢出标志位OF被置为1 此时程序调用into指令且中断屏蔽位IF=1 会调用中断向量号为4的溢出中断程序(函数)

保护模式
32位cpu 将16位运行模式称为实模式 32位运行模式称为保护模式
实模式 段基址存放物理地址 直接操作内存物理地址
保护模式 段基址存放选择子 通过下标对应全局描述符表中的段描述符表的虚拟地址 寻址后由操作系统+cpu转换成真实物理地址
保护模式下 除段寄存器以外的寄存器(通用寄存器 指令指针寄存器 标志寄存器)均为32位 其低位复用16位cpu的寄存器 向高位扩展一个16位的寄存器
保护模式下 新加入段描述符缓冲寄存器 用来缓存内存中的段描述符或实模式下段基址的偏移结果

全局描述符表(GDT) 所以程序公共使用
局部描述符表(LDT) 多任务模式下 每个任务私有的描述符表 任务切换时需重新初始化 极少用到
段描述符 存在于GDT&LDT中
    每个元素64位 用来描述一个段基址信息 其中低32位描述段基址的0-15位和段界限的0-15位(最大偏移量 偏移单位) 高32位描述段基址的16-31位 段界限的16-19位和段的基本信息
    段基本信息包括  
    段偏移单位(G位) 计算段界限的实际值 0: 偏移单位为1字节 1: 偏移单位为4kb字节
    段描述符(type位 S位) type4个字节 标识段是否被访问(A位) 是否为一致性代码段(C位) 是否可读(R位) 是否可执行(X位)
                       S位1个字节 标识段为系统段(0 各种门)或数据段(1 各种代码段 软件运行地址)
    段特权级(DPL 2位) 包括0-3四级 0级权限最高 运行操作系统代码 用户代码一般在3级
    段存在描述(P位) 标识段是否在内存中存在 0: 不存在 1: 存在
    段可用性描述(AVL) 描述段是否可用
    段类型(L位) 描述段位32位或64位  0: 32位 1: 64位 32位cpu默认0
    D/B位 描述段内偏移地址和操作数大小 D位在代码段起效 0: 16位有效地址&操作数 1: 32位有效地址&操作数
                                  B位在栈段起效 0: 使用16位栈寄存器sp 1: 使用32位栈寄存器esp

保护模式保护策略
段寄存器加载选择子时保护 检查描述符表下标是否合法 段类型和寄存器类型是否匹配 段是否存在(P位)
数据段和代码段加载保护 检查段偏移量是否超过段界限
栈段保护 入栈时是否超过栈段界限 (向上扩展可访问段界限最后一个字节 向下扩展可访问段界限最后一个字节-1 防止段碰撞)

特权级
cpu特权级分为0-3 数字越小特权级越高 0为内核特权级 1-2为系统程序特权级(面向虚拟机 硬件驱动程序) 3位用户程序特权级

TSS 任务状态段 处理器硬件支持多任务数据结构 每一任务(进程)都有单独的TSS
TSS保存特权级栈 每一个特权级有单独的栈 任务所需特权级由低到高 从TSS取出高一级特权级栈 特权级由高到低 从高特权级栈中取出低特权级栈地址

CPL 代码段特权级 存在于代码段寄存器中(cs)
RPL 请求特权级 存在于段选择子中 标识当前cpu指令的特权级 当执行代码时 RPL=CPL
DPL 段特权级 存在于段描述符中
特权级检查 当访问数据段/栈段时 需要CPL/RPL特权级大于等于DPL
         当访问代码段时 若为一致性代码段 可允许CPL低特权级向上访问目标CPL高特权级的代码 在执行时CPL保持原低特权级
                      若为非一致性代码段 则需要原CPL等于目标CPL特权级才可访问
特权级的跳转只允许由低到高跳转 (使用jmp&call指令或使用门例程跳转)


物理内存获取 (调用BOIS中断0X15 工作于实模式下)
子功能号 0xe820 获取全部物理内存 返回地址描述符结构
子功能号 0xe801 获取4GB以内的物理内存 0-15mb信息存放在AX/CX寄存器中 以1kb为单位 16mb-4gb信息存放在BX/DX寄存器中 以64kb为单位 (15mb-16mb地址为不可用内存 为历史ISA设备预留)
子功能号 0x88 获取1MB-64MB以内的物理内存 以1kb位单位

内存分页
引入分页前 段基址+段偏移量组成的线性地址直接映射成物理内存地址 内存碎片化严重时较难分配空间
引入分页后 段基址+段偏移量组成的线性地址映射成多个大小相等的虚拟内存页 每个内存页对应连续的一块物理内存 以达到连续线性地址映射非连续物理内存地址的效果 可以较为容易的分配空间

一级页表
页表起始地址存放在cr3寄存器中 每个进程都有独立的页表(从进程角度看 每个进程都独享4GB空间)
每页4KB 4GB被划分为 4GB/4KB=1048576页
线性地址通过 硬件 页部件转化为物理地址 其中线性地址高20位表示对应页在页表中的偏移位置 低12位表示在一页中的地址偏移位置
如 0X1234=00000000000000000001 001000110100 高20位*页表元素大小4字节 获取页表索引 最终物理地址=页表索引对应存放的地址+低12位

二级页表
每个一级页表需要占用4M的物理内存空间(32 * 1048576 = 4M) 且并不是所有页表项在一个进程中都会被使用 因此需要二级页表进一步打散一级页表所占用的物理内存
二级页表由页目录表 页表两级构成 在4G的内存空间中 页目录表共有1024个元素 每个元素4kb 指向一个包含1024个元素的页表 每个页表4kb
在寻址时 线性地址的高10位对应页目录表的下标 中间10位对应页表的下标 后12位对应页表的偏移量
如 0X1234567=00000001001000110100010101100111 高10位*每页目录元素大小4字节 获取页表物理地址 中间10位*页表元素大小4字节 获取页表中位置 低12位为页表元素的偏移量

页表元素组成
高20位指向物理地址的高20位 物理地址低12位默认补0 由线性地址低12位偏移量确定
低12位存放物理内存各种标志位 P位 存在位 0: 不存在于物理内存中 1: 存在于物理内存中
                        RW位 读写位 0: 可读不可写 1: 可读不可写
                        US位 普通用户/超级用户位 0: supervisor级 特权级3的程序不可访问 1: user级 任意特权级程序均可访问
                        PWT位 页级通写位 0: 不是高速缓存页 1: 普通内存/高速缓存页
                        PCD位 页级高速缓存禁止位 0: 禁止页使用高速缓存 1: 启用高速缓存
                        A位 访问位 0: 未被CPU访问 1: 已被CPU访问
                        D位 脏页位 0: 此页未被修改 1: 此页正在被修改
                        PAT位 页属性表位 默认0
                        G位 全局位 0: 非全局位 1: 全局位 (此页常驻TLB中)
                        AVL位 是否可用位 操作系统关注 CPU忽略


线程
对于os来说 最小的任务执行单位为 执行流 os实现了一个任务调度器 通过一定的调度算法 在多个执行流之间调度执行 所谓调度 即将当前执行的任务现成保存在PCB中(寄存器映像 页表) 取出下一个任务PCB中的执行现场 并将程序计数器等寄存器内的值替换为新任务
PCB(proccess control block 程序控制块) 每个执行流对应一个PCB 所有PCB组成进程表 所谓任务调度 即根据进程表来回选择PCB 每个PCB包括 栈 栈指针 寄存器映像 页表 进程状态(阻塞态 就绪态 运行态) pid 优先级 时间片 打开的文件描述符 父进程 等
os 不区分进程或是线程 一个进程中的线程(单线程进程&多线程进程)对应os中的执行流(对于内核线程)
一个进程中的线程共享一组页表 即只有进程之间页表才会相互独立(在32位cpu中拥有独立的4GB虚拟内存空间) 同一个进程中的多个线程可以访问对方的数据(并发问题的产生)
线程分为内核级线程和用户级线程 内核级线程即使用os提供的执行流管理 使用os的任务调度器&PCB 对于os来说 有多少个线程即有多少个执行流
                          用户级线程即由用户程序管理执行流 由程序自己实现任务调度器&PCB 对于os来说 不论有多少个用户级线程 都只有一个该进程的执行流
使用内核级线程能够更加高效的执行任务 不被各种因素阻塞 而用户级线程用户可以更加灵活的管理线程 但是对于os讲只有单一的执行流 线程的并发度和执行效率相对较低 且容易被阻塞
java虚拟机规范不要求虚拟机使用哪种线程模型 单目前默认为内核级线程的实现 也可改为用户级线程实现&混合方式实现


页面置换算法
对于32位cpu来讲 最大的寻址范围是4GB 即页表指向的物理内存为4GB 当所有进程所需的内存超过4GB是 会使用硬盘等外部存储介质作为虚拟内存使用 使用合适的算法将外存页加载到内存中 替换某个内存页进行使用
FIFO(先入先出置换算法) 当需要置换一个内存页时 找到最早被加载到内存中的数据页进行替换 此算法实现较为简单 但是效果较差(最早被加载的内存页未必是最少被访问的)
LRU(最近最久未访问置换算法) 每个内存页维护一个最后访问时间戳 当需要置换时 寻找一个时间戳最早的页进行置换(尽量寻找不常被访问的页)
    对于LRU算法来讲 有一些可行的优化 可将LRU链表用一个指针分为冷数据和热数据两块 当一个数据页被加载到内存时 先进入冷数据的头部 再次被访问(或在较短的时间内再次被访问时) 进入热数据头部 内存页被淘汰时优先淘汰冷数据尾部的页(防止仅被访问一次的内存页干扰) (mysql buffer pool实现了这种算法)
clock置换算法 每个内存页维护一个访问标识 一个修改标识(在页描述符中存在) 当需要置换时 遍历每个内存页 寻找第一个访问标识为0(未被访问)且修改标识为0(未被修改)的内存页置换 若没有找到 则寻找访问标识为0且修改标识为1(未被访问却被修改)的内存页置换 且在遍历过程中将遍历过的内存页访问标识置回0 若仍未找到 则将所有内存页访问标识置为0 重复前两步(此算法同样为寻找最少访问的内存页 且减少了因为内存页被修改而需要刷入硬盘的io开销)
